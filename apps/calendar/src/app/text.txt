ОГЛАВЛЕНИЕ

ОГЛАВЛЕНИЕ	6
СПИСОК СОКРАЩЕНИЙ И УСЛОВНЫХ ОБОЗНАЧЕНИЙ	7
ТЕРМИНЫ И ОПРЕДЕЛЕНИЯ	7
ВВЕДЕНИЕ	9
1. ПОДГОТОВИТЕЛЬНЫЙ ЭТАП	11
1.1 Введение в предметную область	11
1.2 Обзор существующих решений	12
1.3 Обоснование используемых технологий	14
2. ЭТАП ПРОЕКТИРОВАНИЯ	17
2.1 Проработка бизнес и системной аналитики	17
2.2 Проектирование API	19
2.3 Проектирование UI макетов	23
3. ЭТАП РАЗРАБОТКИ	27
3.1 Разработка архитектуры Frontend части	27
3.2 Разработка архитектуры Backend части	31
3.3 Создание логики авторизации	34
3.4 Создание логики взаимодействия с календарем	38
3.5 CI/CD	48
4. АНАЛИЗ РЕЗУЛЬТАТОВ	51
4.1 Проверка просмотра, создания и удаления занятий	51
4.2 Сбор и анализ метрик	54
ЗАКЛЮЧЕНИЕ	56
СПИСОК ИСТОЧНИКОВ	58
ПРИЛОЖЕНИЕ А	61


СПИСОК СОКРАЩЕНИЙ И УСЛОВНЫХ ОБОЗНАЧЕНИЙ
UI – User Interface.
ORM – Object relation mapping.
БД – База данных.
SQL – Structured Query Language.
API – Application programming interface.
HTTP – Hypertext Transfer Protocol.
REST – Representational State Transfer.
MVC – Model-View-Controller
DOM – Document Object Modal
CI – Continuous Integration
ОС – Операционная система
URL – Uniform Resource Locator
JS – JavaScript
API – Application Programming Interface
 
ТЕРМИНЫ И ОПРЕДЕЛЕНИЯ

Клиентское приложение (Frontend часть) – пользовательский интерфейс, который предназначен для предоставления конечному пользователю интуитивно понятного, приятного и эстетичного интерфейса. Frontend приложение отвечает лишь за логику отрисовки данных, получаемых с сервера, и поведение графических компонентов в зависимости от действий пользователя или данных от сервера.
База данных — это упорядоченный набор структурированной информации или данных, которые обычно хранятся в электронном виде в компьютерной системе[1].
Object relation mapping – метод программирования, в котором над базой данных создается объектно-ориентированная абстракция для более удобного взаимодействия языка программирования с текущей базо¬¬й данных. ORM системы позволяют переводить поля, таблицы, записи в классы и объекты используемого языка программирования.
Фреймворк – абстракция над языком программирования, дополняющая его различными методами и объектами, а также задающая стиль написания кода.
Cерверное приложение (Backend) – приложение, которое содержит в себе основную логику системы. Обработка запросов с клиентской части системы, взаимодействие с базой данных, формирование валидного ответа.
Домен – уникальное имя в сети интернет, используемое для идентификации месторасположения сайта. Доменное имя преобразуется в IP адрес, по которому можно посетить веб-сайт.
DOM – Document Object Modal, объектная модель документа для взаимодействия с HTML через JavaScript код.
Монорепозиторий – разновидность реализации монолитной архитектуры, когда у нас все приложение располагается в одном репозитории.
CI – Continuous Integration, стиль разработки, в котором как можно чаще все производные от главной ветки сливаются в главную ветку. Такой инкрементный способ доставки позволяет постоянно иметь актуальную версию продукта в главной ветке.
CD – Continuous Delivery, стиль разработки, в котором доставка кода осуществляется маленькими итерациями. Каждая итерация проходит полный комплекс сборки, тестирования и развертки. Таким образом можно намного раньше обнаружить баги и неполадки в системе.
 
ВВЕДЕНИЕ
Состыковка расписаний всегда была одной из самых сложных задач. Если вы хотите организовать какое-либо мероприятие, занятие, урок на небольшое количество человек, то довольно несложно выбрать наиболее удобное время для всех участников. Однако сложность в разы возрастает, когда участников становиться больше. У каждого есть свой график, дела и занятия, и найти приемлемое для всех время становиться намного труднее. 
Организатор начинает тратить больше времени на выбор подходящей даты. Иногда это заканчивается даже отменой мероприятия.
В современном мире есть довольно много систем для составления графиков. В них вы можете просматривать расписание ваших коллег, друзей и на основании полученных данных подбирать время для общих занятий. 
В нынешних учебных заведениях также используются системы составления расписания, однако они не особо гибкие. График составляется раз в семестр/год и не может быстро перестаиваться.
Если преподаватель захочет поставить внеплановое занятие, которое не прописано в основном расписании, то возникает проблема выбора удобной даты и времени как для него, так и для студентов. Приходится синхронизировать свой график с графиком группы, заводить опросы, опрашивать старост и т.д. С 1-2 группами еще не сложно найти то самое удобное время, но если это 4,5 или 6 групп, то тут задача в разы усложняется. Именно такие внеплановые занятия довольно часто проводятся на факультете ВТ университета ИТМО, поэтому данную проблему можно назвать актуальной.
Целью работы является уменьшение времени поиска удобного для всех групп времени для проведения дополнительных занятий.



Для реализации цели передо мною были поставлены следующие задачи:
	Анализ существующих решений.
	Разработка спецификации и списка тестов для разрабатываемого приложения.
	Проектирование и создание клиентской части приложения.
	Проектирование и создание серверной части приложения.
	Проектирование и создание базы данных приложения.
	Развертывание приложения.
Результатом работы является графическое приложение, которое содержит в себе интуитивно понятный и эстетический дизайн, систему авторизации и удобного просмотра календаря, а также алгоритм расчета свободных временных окон для выбранных групп.  














1. ПОДГОТОВИТЕЛЬНЫЙ ЭТАП

1.1 Введение в предметную область
Основная сложность назначения дополнительного занятия для одной или нескольких групп заключается в отсутствии должной информации у преподавателей о расписании группы. Если основное расписание можно посмотреть в ИСУ, то все внеплановые занятия ни в какой системе не регистрируются.
Допустим преподаватель Z поставил свое внеплановое занятие на четверг 18:00 на X и Y группы. Другой преподаватель тоже планирует поставить на это же время свое занятие, значит ему нужно каким-то образом узнать у каждой группы может ли она присутствовать на занятии в данный день и время. По такому же алгоритму должны действовать все преподаватели:
	Начать опрос всех участников о возможности присутствовать на занятии.
	В случае попадания в удобные даты и время, утвердить занятие, в случае промаха повторить шаг 1, до нахождения той самой даты с временем.
На данных момент шаг 1 решается составлением различных опросов или обращениями к старостам. В обоих случаях преподавателю необходимо дождаться пока все ответят/проголосуют, чтобы собрать необходимую статистику.
Ситуация ухудшается, когда речь заходит о занятиях после окончания семестра. Преподаватели назначают в отрезок от конца семестра до начала экзамена дополнительные занятия для всех должников. Если у студента есть задолженности по двум и более предметам ему необходимо каждый раз контролировать, не пересекается ли одно занятие с другим, и сообщать об этом преподавателю. Не редкий случай, когда ради одного студента дату со временем никто не меняет. Поэтому данная проблема актуальна как преподавателям, так и студентам. Обе стороны страдают от отсутствия синхронизации внеплановых занятий как в конце семестра, так и в течении.

1.2 Обзор существующих решений 
Для начала стоит рассмотреть какие на сегодняшний день готовые решения уже есть на рынке.
Для более четкого представления и сравнения аналогов рассмотрим таблицу 1 (Таблица 1). В качестве сравнительной метрики была выбрана функциональность.
Таблица 1 - Сравнение аналогов
Приложение	Функциональность
Google Calendar		Создание единого календаря и возможность поделиться им со всеми участниками.
	Настройка описания мероприятия с прикреплением либо места, либо ссылки на Google Meet.
	Системы оповещений о предстоящем мероприятии.
Не умеет:
	Запрещать ставить мероприятия друг на друга.
	Без Google почты нельзя пользоваться.
Microsoft Outlook		Полная интеграция с почтой, можно прямо в письме прикрепить ссылку на встречу.
	Возможность просматривать календари других людей, а также принимать приглашения на встречу.
	Система оповещений.
Не умеет:
	Запрещать ставить мероприятия друг на друга.
	Без Microsoft почты нельзя пользоваться.
	Без наличия платной подписки нельзя пользоваться.
Яндекс календарь		Есть удобный механизм подписок на сторонние календари.
	Можно назначить встречу в Телемосте или указать место.
	Оповещения на email, смс или push уведомления.
Не умеет:
	Запрещать ставить мероприятия друг на друга.
	Без Yandex почты нельзя пользоваться.
	Нет возможности группировать людей, из-за этого приходится каждый раз каждого участника по отдельности выбирать.

Из данного анализа можно выделить следующие проблемы:
	Приложения требуют наличие почты или аккаунта от их компании. 
	Приложения не запрещают ставить мероприятия друг на друга, вместо этого участникам присылаются уведомления, и они сами выбирают пойти или нет.
	Не у всех систем есть возможность создания групп людей, которые потом одним нажатием можно добавлять в мероприятие.
Поэтому можно сделать вывод о том, что потребность в создании приложения по управлению расписанием дополнительных занятий есть. Каждая из вышеперечисленных систем старается быть максимально универсальной, но чем универсальнее система, тем хуже она решает конкретные задачи.
1.3 Обоснование используемых технологий
Для создания серверной части приложения был выбран Node.js – open-source кроссплатформенная среда выполнения, основанная на V8, благодаря которой можно использовать JavaScript код для написания серверов. Именно благодаря Node.js можно запускать JavaScript вне браузера.
Node.js был впервые выпущен в 2009 году и сразу приобрел большую популярность. Так как он позволяет писать код на JavaScript, то многие frontend разработчики кроме клиентской части, также смогут самостоятельно проектировать и серверные приложения. На данный момент проект Node.js на Github насчитывает около 50000 звезд, следовательно, можно сделать вывод, что это очень большой и популярный проект. Node.js. В сравнении с Java и C Node.js в разы быстрее благодаря неблокирующей архитектуре. Так как этот проект достаточно популярный, то на данный момент существует множество open-source библиотек и фреймворков, которые позволяют еще легче проектировать серверные части приложений.
Одним из таких фреймворков является Nest.js. Он обладает строгой архитектурой MVC для создания крупномасштабных, тестируемых приложений. Nest.js использует TypeScript, что позволяет добавить в приложение статическую типизацию и избежать многих ошибок до запуска приложения. Этот фреймворк использовали для создания своих систем такие известные компании как Adidas и Roche. Он прост в освоении, имеет MVC архитектуру из коробки, Cron API и другие готовые шаблоны. Все это позволяет меньше задумываться об проектировании и быстрее создавать бизнес-логику.
Также в качестве ORM была выбрана Prisma – объектно-реляционное отображение сущностей базы данных для Node.js и Typescript. Она имеет достаточно просто интерфейс в освоении и уже подготовленные скрипты для генерации типов Typescript по текущей схеме БД.

Prisma скрывает всю логику взаимодействия с БД в себе. Не нужно прописывать вручную SQL запросы, вместо этого можно обратиться к уже типизированным методам, которые сами построят SQL запрос в зависимости от вызванного метода и аргументов. Также Prisma по умолчанию поддерживает фильтрацию, различного вида сортировки и многое другое. Еще она содержит в себе уже готовое UI приложение – Prisma Studio. В нем можно легко создавать, редактировать, обновлять и удалять записи из созданных таблиц.
Помимо серверной части было решено разработать клиентское приложение, так как наличие интуитивно понятного UI для взаимодействия с приложением на сегодня является стандартом. В качестве JS фреймворка был выбран React. Впервые его использовал Facebook в 2011 году, а уже в 2013 фреймворк анонсировали для публичного доступа. Наличие инкапсулированной архитектуры и виртуального DOM дерева для удобного обновления состояния UI лишь малая часть достоинств React. Кроме этого, проект имеет достаточно легкую в понимании документацию и огромное количество обучающих материалов с примерами. 
Из менеджеров состояния использовался Redux, а конкретнее RTK Query - инструмент для получения и кэширования данных, включённый в пакет Redux Toolkit. Эта библиотека позволяет сохранять на клиентском приложении какие-то важные данные, к примеру, информацию о текущем пользователе и не перезапрашивать каждый раз ее у сервера. Также важно отметить, что все запросы к серверу кэшируются, т.е если запрос содержит те же самые параметры, то данные ответа будут браться из кэша. Это позволит ускорить ответ UI на одинаковые запросы пользователя.
 В качестве инструмента управления зависимостями в монорепозитории для UI был выбран NX. Он предоставляет удобные инструменты оптимизации CI, а также через NX graph можно запустить интерфейс просмотра графа зависимостей модулей внутри приложения. 
Для просмотра используемых UI компонентов была использована библиотека Storybook. Storybook дает возможность изолировано разрабатывать компоненты, не запуская основное приложение.
По части тестирования UI были выбраны такие технологии, как Storybook для просмотра всех UI компонентов в различных состояниях, а также снятие скриншотов через Loki. Снятие скриншотов с текущего Storybook было включено в прекоммитные проверки через Husky. Эти проверки нужны для выявления ошибок программы на более ранних этапах разработки, чтобы уменьшить стоимость исправления этой ошибки.
Библиотеку компонентов было решено взять Ant Design. Из достоинств: подробная документация, каждая компонента изображена во всех состояниях и имеет исчерпывающую инструкцию о входящих параметрах.
Всю информацию о пользователях, занятиях, днях и т.д, нужно где-то хранить, поэтому в проект была добавлена еще база данных. Из всех СУБД выбор пал на PostgreSQL. Причины такого выбора были следующими:
	Кроссплатформенность. Так как разработка велась на 3 машинах с разными ОС, то этот пункт был важным.
	Бесплатное использование.
	Большое сообщество и исчерпывающее количество обучающий материалов.
В заключении весь проект состоял из:
	Клиентская часть:
	React
	RTK Query
	NX monorepo
	Loki, Storybook, husky
	Серверная часть:
	Next.js, Typescript, Swagger
	Prisma
	СУБД – PostgreSQL.
 
2. ЭТАП ПРОЕКТИРОВАНИЯ

2.1 Проработка бизнес и системной аналитики
После выбора технологий необходимо составить примерный план как должен выглядеть конечный продукт, что будет в себе содержать и т.д. Систему было принято делать лишь с одной ролью – преподаватель, а значит требуется механизм авторизации. Регистрацию было принято решение не включать в конечный продукт, так как это нарушит безопасность системы. Вместо этого преподавателям будут выданы лично их логины и пароли для входа в приложение. 
Кроме этого, студентам нужна система оповещений о предстоящем занятии, значит необходимо также добавить механизм email рассылки. 
Так как ИТМО нанимает преподавателей разных национальностей, то для удобства UI должен иметь интерфейс в двух языка – английский и русский. Наличие светлой и темной тем определяется темпами разработки приложения. Эту задачу можно отнести в низкоприоритетные. 
Одна из главных задач – разработка алгоритма проверки свободных окон в расписании. Созданных алгоритм должен получать на вход список групп, сверять их с информацией в базе данных и выдавать результат есть ли пересечения у какой-либо группы на планируемое время занятия. Пользователю не должно быть доступно создать занятие на часы от 00:00 до 08:00, а также если входящий диапазон пересекается с каким-либо из уже занятых.
Кроме возможности перемещаться по дням непосредственно через компоненту календаря, также необходимо предоставить возможность перемещения через абсолютный URL в формате */YYYY-MM-DD, к примеру 2024-05-04. Эта возможность ускорит навигацию просмотра занятий по дням. 
На самом календаре должна быть возможность предпросмотра всех занятий со временем и названием урока с сортировкой по возрастанию времени.
¬¬¬¬¬¬Формат взаимодействия пользователя с приложением выглядит следующим образом:
	Авторизация пользователя в системе.
	Выбор дня для создания или удаления занятия.
	Создание занятия
	Выбор названия.
	Выбор участвующих групп.
	Выбор начального времени.
	Выбор конечного времени.
	Выбор места или ссылки на занятие.
	Отправка формы на сервер.
	Автоматическая email рассылка всем студентам в участвующих группах.
     Со стороны программы в момент выбора групп на сервер должен посылаться запрос получения доступных часов для старта занятия. После выбора стартового времени на клиенте вычисляются все заблокированные часы конечного времени. По итогу пользователю отображается виджет с часами и минутами, в котором определенные часы и минуты заблокированы. Use-case диаграмма представлена на рисунке 1 (Рисунок 1).



2.2 Проектирование API
Прежде чем писать контроллеры с сервисами на серверной части нужно установить контракт между Backend и Frontend частями. В качестве удобного инструмента формирования спецификации API я выбрал библиотеку Nestjs/swagger. 
Нам необходимо пользователя регистрировать, а значит нужно иметь какой-то контроллер сверяющий пароль и логин с имеющимися в базе данных паролями и логинами. Также этот контроллер – GET запрос должен выдавать токен, этот токен во всех последующих запросах клиент будет отправлять серверу для идентификации пользователя. Это позволит обезопасить остальные контроллеры от запросов неавторизированных пользователей. Кроме токена в ответе должно посылаться плюсом ФИО пользователя и логин, чтобы в клиентском приложении их можно было добавить в State менеджер и не запрашивать постоянно у сервера.
Далее необходимо создать контроллер получения всех уроков. GET запрос должен принимать лишь токен, по этому токену сервер определяет id пользователя и выводит из базы данных именно его занятия. Ответ должен выглядеть в виде массива занятий. 
Получения уроков по конкретному дню ¬тоже отдельный контроллер – GET запрос, принимающий на вход в параметрах запроса лишь дату, а в заголовках тот же токен. По токену мы определяем id текущего авторизованного пользователя и выводим конкретно его уроки по переданной дате. Дата передается в формате YYYY-MM-DD. В ответе ожидается увидеть массив объектов занятий.
Контроллер на удаление урока – DELETE запрос, который на вход должен принимать id занятия, для однозначной идентификации урока в базе, а также токен для установления авторизованный ли клиент пытается удалить урок. 
Контроллер создания занятия – POST запрос, который должен принимать объект урока целиком. Этот же контроллер после создания записи в базе данных должен рекурсивно обходить всех студентов участвующих групп и отправлять им письмо на прикрепленную почту о созданном уроке.
Контроллер поиска заблокированных стартовых часов для занятия – POST запрос, принимающий дату в формате YYYY-MM-DD и числовой массив идентификационных номеров групп. Внутренняя логика контроллера должна рекурсивно обходить каждую группу и выводить все занятые часы выбранных групп. К примеру, возьмем две группы A и B, значит алгоритм должен выводить симметричную разницу в виде A^B представленную на рисунке 2 (Рисунок 2). 






                     Рисунок 2 - Симметричная разница
Формат ответа должен содержать массив объектов, в котором в каждом будет отображен заблокированный час и массив заблокированных минут в этом часе.
Последний контроллер получения всех групп – GET запрос, проверяющий лишь авторизацию пользователя по токену и выдающий список всех существующих в системе групп. Этот контроллер нужен для выбора преподавателем всех необходимый групп при создании занятия.
По итогу всего вышеперечисленного был спроектирован подробный Swagger, который запускается одновременно со стартом приложения на отдельном URL. Swagger изображен на рисунке 3 (Рисунок 3) и рисунке 4 (Рисунок 4)

Рисунок 3 – Swagger

Рисунок 4 - пример описания контроллера
Написание Swagger осуществлялось через удобные теги, предоставляемые библиотекой Nestjs/swagger. Пример использования тегов изображен на рисунке 5 (Рисунок 5)

2.3 Проектирование UI макетов
Чтобы начать разрабатывать UI нужно прежде всего определиться какие страницы, компоненты, виджеты, цветовая гамма, расположение блоков и многое другое будет в конечном варианте приложения. Для разработки UI макетов я воспользовался приложением Figma – веб-приложение, помогающие проектировать интерфейсы на уровне простых компонент без сложной логики с запросами к серверу и т.д. Тем не менее с помощью Figma можно прописать куда будет переходить пользователь по какому-либо триггеру (нажатие кнопки/истечение таймера и т.д).
У Figma есть бесплатная открытая библиотека уже готовых макетов, которые можно взять за основу. Также я искал другие проекты на сторонних сайтах для вдохновения. 
Проектирование началось со страницы авторизации – именно с нее пользователь начинает взаимодействовать с приложением. Важно было отобразить логотип приложения, а также форму авторизации. Макет было решено делать только в темной теме для ускорения процесса. Итоговая страница пользователя на макетах изображена на рисунке 6 (Рисунок 6).
Также было решено сверху приложения добавить шапку с функциями смены темы и языка приложения. Если пользователь авторизован, то логотип перемещается в шапку, а также в ней пишется логин текущего пользователя.
Далее необходим был набросок страницы календаря. Я решил с левой части расположить меню приложения, где будут располагаться в дальнейшем ссылки на различные другие страницы приложения. Сверху также оставить шапку. По итогу контент на странице кроме левого меню и шапки будет динамический и меняться в зависимости от действий/переходов пользователя.
Также календарь должен иметь в себе предпросмотр всех занятий по дням, поэтому из UI библиотеки Ant Design было решено брать компоненту календаря в развернутом в виде. Конечный вариант представлен на рисунке 7 (Рисунок 7).
Цветовая гамма приложения была выбрана заранее через утилиту ant-design/colors. Утилита экспортирует функцию generate, которая принимает на вход код цвета в формате HEX, и выдает массив оттенков этого цвета. По итогу цветовая палитра для темной и светлой тем выглядела следующим образом:
export const Colors = {
    light:{
        primary: generate('#EFEFF3')[5],
        secondary: generate('#F3F3F3')[6],
        bordered: generate('#EBEBEB')[5],
        text: generate('#000000')[5],
        textWarning: '#d74848',
    },
    dark: {
        primary: generate('#000000')[5],
        secondary: generate('#1F2023')[5],
        bordered: generate('#26272C')[5],
        text:  generate('#ffffff')[5],
        textWarning: '#ff0000'    
}

3. ЭТАП РАЗРАБОТКИ

3.1 Разработка архитектуры Frontend части
Два важных требования к архитектуре клиентской части приложения были расширяемость и изолированность каждого модуля. Благодаря изолированности мы можем обеспечить минимум зависимостей между бизнес-модулями, и обеспечить наибольший параллелизм разработки. Также одно из важных свойств архитектуры должно было быть возможность максимального переиспользования одинаковых компонент, чтобы не плодить однообразный код
После продолжительных поисков выбор остановился на FSD (Feature-Sliced design) – подход, при котором мы проектируем наше приложение так называемыми слоями. Чистый FSD применить довольно трудно, если соблюдать все рекомендации из документации [3].
Так как я использовал NX, то одна из его возможностей – построение графа зависимостей внутри приложения. Конечный граф изображен на рисунке 8 (Рисунок 8).


Для более понятного рассмотрения я нарисовал свой граф архитектуры Frontend части, изображенный на рисунке 9 (Рисунок 9).



















На этом рисунке рассмотрим основные блоки:
	App – главная точка входа в приложение. Здесь располагается подключение различных провайдеров (например State менеджеры, темизация и т.д), проверяется авторизация пользователя, настраивается Redux хранилище.
	System – компонента, отвечающая за расстановку левого меню, шапки приложения и навигацию внутри системы.
	Pages – блок со всеми страницами приложения. Страницы хранят минимум бизнес логики и отвечают только за правильную сборку компонентов из виджетов.
	Widgets – блок со всеми компонентами, которые хранят в себе несколько feature, а также связывает Redux хранилище с действиями пользователя.
	Features – блок со всеми компонентами, которые хранят в себе какие-то API вызовы, обработку их ответов, бизнес-логику и т.д. 
	Shared – все переиспользуемые переменные/функции приложения. Блок configs содержит информацию о все навигации внури приложения, подключение к Local Storage и настройка интернационализации. 
Блок ui содержит все переиспользумые компоненты без какой-либо бизнес логики. В моем случае настраивались стили под 2 темы (светлую/темную) из компонентной базы Ant Design.
Каждый такой пункт – это отдельный проект, со своим package.json и зависимостями. Это было сделано, чтобы отслеживать от каких библиотек зависит каждый слой, а также разрешено ли этому слою зависеть от конкретной библиотеки. Разрешения на импорты и экспорты также настраивались с помощью NX по примеру ниже
"depConstraints": [
              {
                "sourceTag": "*",
                "onlyDependOnLibsWithTags": ["*"]
              },
              {
                "sourceTag": "app",
                "onlyDependOnLibsWithTags": ["*"]
              },
              {
                "sourceTag": "widgets",
                "bannedExternalImports": ["antd", "features"]
              },
              {
                "sourceTag": "features",
                "bannedExternalImports": ["antd", "widgets", "app"] }

Из примера можно заметить поле sourceTag в объектах. Каждый слой имел свой тег, именно на него смотрел линтер при проверках разрешений экспортов/импортов. Если хотя бы в одном проекте есть ошибки одного из линтеров, то загрузить свои изменения на Github будет невозможно.

	Разработка архитектуры Backend части
Так как для разработки серверной части я использовал фреймворк Nest.js, то по умолчанию удобнее было использовать уже предопределенную систему проектирования модулей. Все приложение состоит из различных модулей, которые с помощью инъекций подключаются к главному модулю приложения App. Каждый модуль состоит из контроллеров, сервисов, DTO моделей (объект, который контроллер принимает в качестве аргументов от клиентской части приложения) и Entity (объект, который контроллер возвращает клиентской части приложения в качестве ответа). Общение сервера и Frontend части происходит при помощи протокола HTTP. Он был выбран как один из самых популярных и наиболее подходящих для моей задачи. Подробная архитектура Backend части изображена на рисунке 10 (Рисунок 10)
	App Module – главный модуль, отвечающий за распределения запросов с клиента на отвечающие за их обработку модули.
	Auth Module – модуль, отвечающий за авторизацию пользователя в системе. Сверяет пароль и логин с базой данных, а также выдает в качестве ответа токен авторизации.
	User Module – модуль, отвечающий за поиск и изменение информации в базе данных о данном пользователе. К примеру, смена ФИО.
	Group Module – модуль, отвечающий за все взаимодействия с таблицей группы в базе данных. К примеру, получение всех групп, зарегистрированных в системе.
	Lesson Module – модуль, отвечающий за создание, чтение и удаление информации о занятиях. Также этот модуль выдает заблокированные часы, когда занятие поставить нельзя.
	Mail Module – промежуточный модуль между библиотекой NodeMailer. Собирает тело письма для рассылки, отправителя и получателей. 
Как уже упоминалось выше в Nest.Js используется модульная архитектура. Пример одного из модулей изображен ниже
@Module({
  providers: [LessonService, PrismaService],
  controllers: [LessonController],
  exports: [LessonService],
  imports: [GroupModule, MailerModule, StudentModule],
})
export class LessonModule {}

Данный модуль связывается с сервисом базы данных (PrismaService) и сервисом занятия (LessonService). Чтобы использовать эти сервисы необходимо также импортировать их модули. Более подробно про модульную архитектуру написано в документации Nest.js[2].
Также в рамках разработки Backend части была спроектирована база данных, схема которой изображена на рисунке 11 (Рисунок 11).













	Создание логики авторизации
Первое, что необходимо было сделать – авторизацию пользователя, потому что нам нужно знать какой преподаватель создает уроки, какое у него расписание и т.д. Сделав небольшой обзор вариантов авторизации, я выделил следующие способы:
	Через обычный логин, пароль – самый быстрый и простой способ.
	Через Google аккаунт или сторонние сервисы – сложнее, но зато пользователям не нужно запоминать отдельные логин и пароль для моего приложения.
	Биометрическая аутентификация – самый сложный вариант, требует подключения WebAuthn Api, но зато предоставляет быстрый вход в систему по отпечатку пальца или лицу.
После оценки трудозатрат на каждый из способов было принято решение для первой версии системы сделать обычную авторизацию через логин и пароль. 
На стороне клиента реализация отправки формы выглядела следующим образом (подробнее в Приложении А):
         const [form] = Form.useForm<TLoginSchemaArgs>();
  
  const handleFinish = useCallback((form: TLoginSchemaArgs) =>{
    sendAuth(form)
    form.username && dispatch(loginActions.setUsername(form.username))
    form.password && dispatch(loginActions.setPassword(form.password))
    dispatch(loginActions.setRemember(true));
 }, [dispatch, sendAuth]
	Данные отправляются с помощью заранее прописанного запроса через RTK Query, а также метод handleFinish сохраняет в хранилище Redux данные для авторизации. 
	На UI отрисовка компонент формы авторизации изображена на рисунке 12 (Рисунок 12)

Рисунок 12 - UI реализация авторизации
	Чтобы держать сессию активной, сервер выдает специальный токен авторизации, по которому можно однозначно определить какой сейчас пользователь в системе авторизован. Данный токен располагается в заголовках каждого запроса, кроме публичных контроллеров, к примеру контроллер авторизации. Реализация выдачи токена происходит через сервис Auth Guard – он оборачивает все серверное приложение в провайдер, который блокирует все запросы без токена. Однако контроллер авторизации необходимо было оставить публичным, поэтому был разработан специальный тег Public в качестве открытого ключа. Код сервиса Auth Guard выглядит следующим образом (подробнее в Приложении А):
    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);
    if (!token) {
      throw new UnauthorizedException();
    }
    try {
      const payload = await this.jwtService.verifyAsync(token, {
        secret: process.env.SECRET_KEY,
      });
            request['user'] = payload;
    } catch {
      throw new UnauthorizedException();
    }
    return true;
  }
Сам токен генерируется специальной библиотекой JWT. Также мы можем вшить в токен всю информацию, которую нам необходимо в нем хранить. Пример выдачи токена изображен на рисунке 13 (Рисунок 13)
 
Рисунок 13 - пример запроса на авторизации
Если токен некорректный, или его вообще нет в заголовках запроса, то в ответе будет выдана ошибка, изображенная на рисунке 14 (Рисунок 14)
По итогу мы получили рабочую версию авторизации, которую можно протестировать через UI в браузере, а также выдачу специального токена, через который можно будет однозначно определить текущего авторизованного пользователя в системе. Этот токен мы будем хранить в Local Storage и посылать при каждом последующем запросе к серверу вместо Id пользователя.

3.4 Создание логики взаимодействия с календарем
На этапе проектирования UI макетов я уже выделил основные требования к компоненте календаря, а именно это должен быть развернутый календарь с возможностью переключения месяцев и предпросмотр занятий дня. Готовая компонента Ant Design Calendar имела уже весь необходимый функционал, поэтому мне оставалось лишь обеспечить необходимый контракт между базой данных, сервером и клиентским приложением. 
Со стороны клиентской части необходимо было темизировать компонент календаря в двух темах(светлая/темная), создать API запрос и функцию-преобразователь ответа сервера к формату данных, требуемый компонентом календаря из UI библиотеки. Все цвета я определил через глобальный объект и с помощью библиотеки styled-theming для Styled components определил функции цветов для текста, фона и эффектов наведения мыши. Пример таких функций ниже:
       export const backgroundColor = theme('mode', {
    light: Colors.light.primary,
    dark: Colors.dark.primary,
  });

export const textColor = theme('mode', {
    light: Colors.light.text,
    dark: Colors.dark.text,
  });

export const borderColor = theme('mode', {
    light: Colors.light.bordered,
    dark: Colors.dark.bordered,
  });

  export const hoverBackgroundColor = theme('mode', {
    light: Colors.light.secondary,
    dark: Colors.dark.secondary,
  });
Также для созданной компоненты была создана история в Storybook проекта, изображенная на рисунке 15 (Рисунок 15).
Такие истории помогают изолированного без запуска всего приложения разрабатывать компоненты, а также через Storybook легко проводить скриншотное тестирование.
После создания API запроса к серверу с передачей токена пользователя началась разработка backend части бизнес-логики работы с календарем. Задача состояла лишь в расшифровке полученного токена для определения текущего пользователя, а также обращение в базе данных за всеми занятиями преподавателя. Сам сервис получения данных оказался довольно простым, однако в нем я еще добавил функцию сортировки.
  async findAllByUserId(userId: number): Promise<LessonEntity[] | undefined> {
    const allLessons = await this.prisma.lesson.findMany({
      where: {
        teacher_id: userId,
      },
    });
    return _.sortBy(allLessons, 'start_time')}
Контроллер проверяет наличие корректного токена, и если с ним есть какие-то проблемы, то выводит ошибку Unauthorized.
Возвращаясь снова к UI части необходимо было создать страницу дня, в которой выводились в виде карточек все занятия в текущем дне, и была возможность удаления и создания занятия. Также нужно было добавить быстрый переход по дням через URL. Последнюю задачу я решил через добавление в URL даты в формате YYYY-MM-DD. Если в URL будет дата неподходящая под формат, то выведется модальное окно с ошибкой, изображенной на рисунке 16 (Рисунок 16).
   	Кроме проверки корректности даты на UI также дата проверяется на стороне сервера и выдается соответствующая ошибка, изображенная на рисунке 17 (Рисунок 17)
Карточка занятия и вся ее логика взаимодействия с api была вынесена в отдельную feature модуля Features. Как по примеру с календарем для компоненты карточки также были разработаны два варианта отображения под текущие темы и написана история. Список карточек был уже выделен в модуль Widgets. Такое структурное разделение было сделано с целью, чтобы мы не запоминали где-то id каждой карточки, а карточка сама знала какой у нее id и по клику на кнопку удаления могла удалить сама себя, т.е инкапсулировали логику взаимодействия с компонентом внутри самого компонента. Пример вывода списка карточек занятий изображен на рисунке 18 (Рисунок 18).
	Также по кнопке добавить занятий вылетает слева окно создания занятия. Это окно – это отдельная feature, со своим слоем взаимодействия с API, типами и вспомогательными функциями. UI представление окна создания занятия представлено на рисунке 19 (Рисунок 19)
	 
Рисунок 19 - UI добавления занятия
Изначально пользователь не видит поле выбора времени, оно появляется только после выбора групп. Это было сделано намерено, так как на компоненту Select назначен слушатель событий onFocus, т.е когда пользователь отведет мышку от этого поле, на сервер пошлется запрос. Ответом на этот запрос будет список заблокированных стартовых часов начала занятия. Этот список передается в UI компоненту TimePicker и через графический интерфейс пользователь чисто физически не сможет поставить начальное время занятия на заблокированные часы. Пример можно наблюдать на рисунке 20 (Рисунок 20).
Т.е на 16 и 17 часов для 13 группы уже нельзя поставить занятие. Реализация алгоритма вывода стартовых заблокированных часов представлена ниже (подробнее в Приложении А):
           const disabledRange = _.uniqBy(rangeTimes, 'start');
    const result: DisabledTimeEntity[] = [];
    disabledRange.forEach((value) => {
      const startHour = Number(value.start.split(':')[0]);
      const endHour = Number(value.end.split(':')[0]);
      for (const i of _.range(startHour, endHour + 1)) {
        result.push({
          disableHour: i,
          disabledMinutes: _.range(0, 61),
        });
      }
      for (const i of _.range(0, 8)) {
        result.push({
          disableHour: i,
          disabledMinutes: _.range(0, 61),
        });
      }
    });

    return _.sortBy(_.uniqBy(result, 'disableHour'), 'disableHour'); 
Каждый алгоритм требует анализа, насколько он оптимальный, быстрый и экономный по ресурсам. Поэтому посчитаем его сложность:
	Запрос к базе данных – зависит от количества найденных элементов. Если их n, то сложность данной операции будет O(n).
	Операция map(rangeTimes) – линейная сложность O(n).
	Операция удаления дубликатов (disabledRange) – логарифмическая сложность O(n log n), так как операция uniqBy из библиотеки lodash проводит предварительную сортировку массива перед удалением.
	Цикл disabledRange – имеет два вложенных цикла, в худшем случае будут иметь сложность O(x*y), где x – количество элементов в disabledRange, а y – длина каждого временного диапазона.
	Создание массива result - сложность O(x*y)
	Удаление дубликатов и сортировка – сложность O(z log z), где z количество элементов в result.
Итого общая сложность алгоритма составляет O(n + x * y + z log z)

Также присутствовал еще один алгоритм определения конечного времени занятия, но уже на клиентской части приложения. Его реализация можно наблюдать ниже:
const disableHours = _.map(disabledTimes, 'disableHour')
const min = disableHours.find((item)=> item>startHour)
if(min){
   return {
    disabledHours: () => _.concat(_.range(0, startHour),       _.range(min+1,maxEndTime)),
   disabledMinutes: (selectedHour: number) => {
                    if (selectedHour === min) {
                          return _.range(1,60)
                        }
                        return []
                }
            }
        }
             
return {disabledHours: () => _.concat(_.range(7, startHour), disableHours)}}
            }
	
	Посчитаем также его сложность:
	Операция map – линейная сложность O(n).
	Операция find – линейная сложность O(n).
	Операция concat – O(n+m), где n и m длины массивов, переданные в качестве аргументов.
	Генерация массива от 1 до 60 – O(1), так как 60 константа.
	Операция concat – O(n+m).
Итого сложность алгоритма зависит в основном от параметра disabledHours, следовательно сложность можно оценить в O(n), при n равной переменной disabledHours.

Остальные части информации о занятии – место или ссылка на комнату были не слишком сложные и просто отправлялись серверу при конечной отправке всей формы. Однако стоить также отметить реализацию функции сохранения занятия.
  async create(
    createLessonDto: CreateLessonDto,
    teacher: { id: number; username: string; fullname: string },
  ): Promise<void> {
    createLessonDto.group_ids.map(async (group) => {
      const students = await this.studentService.getStudentByGroupId(
        createLessonDto.group_ids,
      );
      const recipients = students.map((student) => ({
        name: student.name,
        address: student.email,
      }));
      await this.mailerService.sendEmail(emailDto);
      return await this.prisma.lesson.create({
        data: buildObject,
      });
    });
  }

Кроме сохранения занятия в базу данных эта функция также обращается к сервису взаимодействия с модулем почты, собирает тело письма и выполняет рассылку всем участвующим студентам о новом занятии. Отправленное письмо изображено на рисунке 21 (Рисунок 21)
 
Рисунок 21 - пример письма о новом занятии

3.5 CI/CD
В приложении также были налажены процессы CI/CD как для клиентской, так и для серверной части приложения.
По frontend части были написаны:
	Прекоммитные проверки с помощью библиотеки husky.
	Настройка Github Actions при каждом push или pull request в production(master) ветку.
Само тестирование frontend части включало в себя:
	Проверка правильной типизации кода через TypeScript.
	Проверка соблюдения единой стилистики через Eslint.
	Unit тестирование функций через Jest.
	Компонентное тестирование React компонент через React testing library.
	Скриншотное тестирование через Storybook и loki.

Также так как на клиентском приложении использовался NX, то благодаря нему скорость CI возрастала в разы. Он кешировал результаты прошлого тестирования, отслеживал какие модули были затронуты в текущем коммите и тестировал только их. Различия коммитов NX сравнивал с последним коммитом production(master) ветки. YAML файл для Github Actions представлен ниже:
jobs:
  main:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      # Cache node_modules
      - uses: actions/setup-node@v3
        with:
          node-version: 20
          cache: 'npm'
      - name: Restore cached npm dependencies
        uses: actions/cache/restore@v3
        with:
          path: |
            node_modules
            ~/.cache/Cypress # needed for the Cypress binary
          key: npm-dependencies-${{ hashFiles('package-lock.json') }}
      - run: npm i
      - name: Cache npm dependencies
        uses: actions/cache/save@v3
        with:
          path: |
            node_modules
            ~/.cache/Cypress # needed for the Cypress binary
          key: npm-dependencies-${{ hashFiles('package-lock.json') }}
      - run: npx nx affected -t lint,test,test:ui --base=origin/main~1 --head=origin/main --parallel=3

NX позволяет с помощью флага --parallel распараллеливать выполнение задач на несколько потоков вместо создания отдельных блоков(jobs), а также здесь представлено кеширование E2E тестов, но их реализации не было в данной версии приложения.

По части CD frontend и backend части были подключены к бесплатному хостингу от Vercel. Он отслеживает появление новый коммитов и производит пересборку приложения. Из важных особенностей – в режиме pull request Vercel предоставляет удобный интерфейс для проверки корректности отображения графических компонент. Также можно оставить комментарий при наличии ошибок, и он появиться в основном PR. Т.е проверка происходит не только кода, но и UI представления. Пример изображен на рисунке 22 (Рисунок 22).
Также в том же Vercel можно подключить бесплатную базу данных, что я и сделал. Прописав env переменные подключения к удаленной базе данных мое серверное приложение стало полноценно работать. В бесплатном тарифе Vercel предоставляет базу данных с размером в 256 МБ и 60 часами процессорного времени, что вполне хватало для моих целей и задач.

4. АНАЛИЗ РЕЗУЛЬТАТОВ

4.1 Проверка просмотра, создания и удаления занятий
Для проверки CREATE, READ, DELETE операций база данных была заполнена тестовыми занятиями. Отображение уроков в режиме календаря изображено на рисунке 23 (Рисунок 23)
На рисунке видно, как все имеющиеся уроки у преподавателя отображаются в режиме предпросмотра, а также если уроков слишком много, то отображается скролл для прокрутки контента. Сегодняшняя дата выделяется специальным цветом, также календарь имеет удобные кнопки для навигации по месяцам и годам. Далее рассмотрим отрисовку просмотра занятий в режиме дня на рисунке 24 (Рисунок 24).




На этой странице мы видим, как отображаться список карточек занятий, этот список имеет собственную полосу прокрутки, т.е дата дня и кнопка добавления занятия всегда находятся сверху. Контент карточки корректно отрисовывает название предмета, группу, время и место проведения.
Также проверим функцию удаления занятия по нажатию на иконку корзины любой карточки на рисунке 25 (Рисунок 25)






Логика создания также корректно отрабатывает, к примеру создадим занятие с названием TEST. Результат можно наблюдать на рисунке 26 (Рисунок 26)

4.2 Сбор и анализ метрик
Для анализа конечного продукта были выбрана 1 метрика – время создания занятия. В эту величину также уже включено время поиска удобного времени для проведения занятия.
Метрика будет анализироваться в сравнении с текущим решением проблемы – опросами в мессенджерах. Анализ представлен в таблице 2(Таблица 2).
Количество групп	Dop Scheduler	Опросы
1	0,1h	5-7h
2	0,1-0,3h	24h-36h
>2	0,1-0,3h	48-∞h
Таблица 2 - сравнение созданного продукта с текущем решением
Также отобразим тенденцию изменения времени при увеличении количества участвующих групп в виде графика, представленный на рисунке
Рисунок 27 - сравнительный график зависимости количества групп от часов
	Из графика можно вывести формулы для анализа тенденции изменения времени при увеличении количества групп. 
В случае опросов это y=14,286x-2,4286, в случае разработанного продукта это y= 0,0321x+0,09
Из этих данных можно сделать вывод, что созданный продукт помогает уменьшить по сравнению с текущим решением поиск удобного времени для проведения занятия в 444.5 раза.¬¬¬¬¬
























ЗАКЛЮЧЕНИЕ

Целью данной работы являлась уменьшение времени поиска удобного для всех групп времени для проведения дополнительного занятия. По выполнению работы цель была выполнена и достигнута в полном объеме. Разработанная система полностью соответствует всем требованиям, заявленным в техническом задании, а также выполняет все поставленные перед ней задачи. Результатом работы стало веб-приложение, помогающее в двух режимах (календаря и дня) просматривать, удалять и создавать занятия. Более того система вводит единое расписание, которое позволяет синхронизовать графики занятий нескольких групп между собой.
По ходу проектирования появлялись и удалялись различные функциональные требования. Это было связано с более глубоким изучением предметной области и ресурсов для выполнения определенных требований. Также многие требования в силу приоритезации задач были опущены и добавлены в графу “Дальнейшие улучшения”. К примеру, одно из таких улучшений – добавление UI панели для администратора, чтобы не лезть каждый раз в БД для добавления пользователей, групп и студентов.
Из появившихся во время разработки доработок можно выделить –2 языка интерфейса, 2 цветовые темы приложения и быстрая навигация по дням через абсолютный URL. По поводу 2-ух языков и тем – это текущий стандарт любого UI приложения, поэтому этот функционал было решено добавить.
Основные трудности были на первый этапах проектирования и разработки. Много времени ушло на поиск подходящих UI макетов, цветов, разработки архитектуры UI и серверной части. Также в этом проекте я намерено взял неиспользуемые мной ранее фреймворки для их практического изучения. Один из таких новых для меня инструментов стал NX.
Данная работа кроме решения четко поставленных перед нею задач также улучшила мою компетенцию в профессиональной сфере. Я познакомился и опробовал на практике много новых технологий, научился считать сложность алгоритмов, а также проектировать наиболее оптимальные решения. Исходя из всего вышеперечисленного я оцениваю свою работу полезной.
Весь код приложения можно найти по следующим ссылкам:
	Frontend часть - https://github.com/progagoda/dop-schedule-frontend
	Backend часть - https://github.com/progagoda/dop-scheduler-backend




















СПИСОК ИСТОЧНИКОВ
	Документация библиотеки компонентов Ant Design [Электронный ресурс] – URL: https://ant.design/docs/react/introduce. – Режим доступа: свободный. – Дата обращения: 11.05.2024.
	 Документация фреймворка React [Электронный ресурс] – URL: https://ru.reactjs.org/docs/getting-started.html. – Режим доступа: свободный. – Дата обращения: 11.05.2024.
	 Документация СУБД PostgreSQL [Электронный ресурс] – URL: https://www.postgresql.org/. – Режим доступа: свободный. – Дата обращения: 11.05.2024.
	Документация фреймворка Nest.js [Электронный ресурс] – URL: https://docs.nestjs.com/.– Режим доступа: свободный. – Дата обращения: 11.05.2024.
	Документация библиотеки Redux Toolkit [Электронный ресурс] – URL: https://redux-toolkit.js.org/tutorials/overview/.– Режим доступа: свободный. – Дата обращения: 11.05.2024.
	Документация библиотеки Prisma [Электронный ресурс] – URL: https://www.prisma.io/docs/orm/.– Режим доступа: свободный. – Дата обращения: 11.05.2024.
	Документация библиотеки Storybook [Электронный ресурс] – URL: https://storybook.js.org/docs/get-started/.– Режим доступа: свободный. – Дата обращения: 11.05.2024.
	Документация библиотеки NX [Электронный ресурс] – URL: https://nx.dev/getting-started/intro/– Режим доступа: свободный. – Дата обращения: 11.05.2024.
	Документация языка программирования Typescript [Электронный ресурс] – URL: https://www.typescriptlang.org/docs/ – Режим доступа: свободный. – Дата обращения: 11.05.2024.
	 Документация языка программирования JavaScript [Электронный ресурс] – URL: https://developer.mozilla.org/en-US/docs/Web/JavaScript/– Режим доступа: свободный. – Дата обращения: 11.05.2024.
	Документация Github Actions [Электронный ресурс] – URL: https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions/
Режим доступа: свободный. – Дата обращения: 11.05.2024.
	Симпсон. К, Вы не знаете JS, Типы и грамматические конструкции; перевод с английского ООО Издательство «Питер», 2019. — 240 с.: ил. — (Серия «Бестселлеры O’Reilly»). ISBN 978-5-4461-1266-1.
	Симпсон. К, Вы не знаете JS, Замыкания и объекты; перевод с английского ООО Издательство «Питер», 2020. — 336 с.: ил. — (Серия «Бестселлеры O’Reilly»). ISBN 978-5-4461-1255-5.
	Симпсон. К, Вы не знаете JS, Асинхронная обработка и оптимизация; перевод с английского ООО Издательство «Питер», 2020. — 352 с.: ил. — (Серия «Бестселлеры O’Reilly»). ISBN 978-5-4461-1313-2.
	Симпсон. К, Вы не знаете JS, ES6 и не только; перевод с английского ООО Издательство «Питер», 2020. — 336 с.: ил. — (Серия «Бестселлеры O’Reilly»). ISBN 978-5-496-02445-7.
	Мартин. Р, Чистая архитектура. Искусство разработки программного обеспечения; перевод с английского ООО Издательство «Питер», 2021. — 352 с.: ил. — (Серия «Библиотека программиста»). ISBN 978-5-4461-0772-8
	Османи.Э, Лидия.Х, Изучение шаблонов проектирования на JavaScript [Электронный ресурс] – URL: https://www.patterns.dev/#patterns  – Режим доступа: свободный. – Дата обращения: 11.05.2024.
	Черных.Б. Профессиональный TypeScript. Разработка масштабируемых JavaScriptприложений. — СПб.: Питер, 2021. — 352 с.: ил. — (Серия «Бестселлеры O’Reilly»). ISBN 978-5-4461-1651-5

	Фримен.Э, Робсон.Э, Сьерра.К, Бейтс.Б, Head First. Паттерны проектирования. 2-е изд; перевод с английского ООО Издательство «Питер», 2022. — СПб.: Питер, 2022. — 640 с.: ил. — (Серия «Head First O’Reilly»). ISBN 978-5-4461-1819-9.
	 Рефакторинг и шаблоны проектирования [Электронный ресурс] – URL: https://refactoring.guru/ – Режим доступа: свободный. – Дата обращения: 11.05.2024.
 
ПРИЛОЖЕНИЕ А
         const [form] = Form.useForm<TLoginSchemaArgs>();
  
  const handleFinish = useCallback((form: TLoginSchemaArgs) =>{
    sendAuth(form)
    form.username && dispatch(loginActions.setUsername(form.username))
    form.password && dispatch(loginActions.setPassword(form.password))
    dispatch(loginActions.setRemember(true));
 }, [dispatch, sendAuth]
return (
  <Form
    form={form}
    style={{width:350}}
    name="basic"
    requiredMark
    initialValues={{ remember: true }}
    onFinish={handleFinish}
    autoComplete="off"
  >
    {isError && <Typography textWarning>{t('messages.error')}</Typography>}
    <Form.Item<TLoginSchemaArgs>
      wrapperCol={{span: 25 }}
      name="username"
      rules={[{ required: true, message: t('messages.requiredUsername') }]}
    >
      <Input placeholder='Login'/>
    </Form.Item>

    <Form.Item<TLoginSchemaArgs>
      wrapperCol={{span: 25 }}
      name="password"

      rules={[{ required: true, message: t('messages.requiredPassword') }]}
    >
      <FormPassword placeholder='Password'/>
    </Form.Item>

    <Form.Item wrapperCol={{offset: 9, span:25}}>
      <Button loading={isLoading }type="primary" htmlType="submit">
        {t('buttons.login')}
      </Button>
    </Form.Item>
  </Form>
    )
Таблица 3 -  UI форма авторизации


export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(
    private jwtService: JwtService,
    private reflector: Reflector,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    if (isPublic) {
      // 💡 See this condition
      return true;
    }
    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);
    if (!token) {
      throw new UnauthorizedException();
    }
    try {
      const payload = await this.jwtService.verifyAsync(token, {
        secret: process.env.SECRET_KEY,
      });
      // 💡 We're assigning the payload to the request object here
      // so that we can access it in our route handlers
      request['user'] = payload;
    } catch {
      throw new UnauthorizedException();
    }
    return true;
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
Таблица 4 - логика выдачи и проверки токена
  async getDisabledStartTime({
    date,
    group_ids,
  }: DisabledStartTimeDto): Promise<DisabledTimeEntity[]> {
    const lessons = await this.prisma.lesson.findMany({
      where: {
        group_id: {
          in: group_ids,
        },
        date: date,
      },
    });
    const rangeTimes = lessons.map((lesson) => ({
      start: lesson.start_time,
      end: lesson.end_time,
    }));

    const disabledRange = _.uniqBy(rangeTimes, 'start');
    const result: DisabledTimeEntity[] = [];
    disabledRange.forEach((value) => {
      const startHour = Number(value.start.split(':')[0]);
      const endHour = Number(value.end.split(':')[0]);
      for (const i of _.range(startHour, endHour + 1)) {
        result.push({
          disableHour: i,
          disabledMinutes: _.range(0, 61),
        });
      }
      for (const i of _.range(0, 8)) {
        result.push({
          disableHour: i,
          disabledMinutes: _.range(0, 61),
        });
      }
    });

    return _.sortBy(_.uniqBy(result, 'disableHour'), 'disableHour');
  }

Таблица 5 - Реализация алгоритма вывода стартовых заблокированных часов
